# 「建议收藏」词法作用域

作用域可以视为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域根据标识符名称进行变量查找。

作用域共有两种主要的工作模型，第一种是最为普遍的，被大多数编程语言所采用的<u>词法作用域</u>，我们会对这种作用域进行深入讨论。另外一种叫做<u>动态作用域</u>，仍有一些编程语言在使用。

## 词法阶段

大多数标准化语言编译器的**第一个工作阶段叫做词法化**，<u>词法化的过程会对源代码中的字符串进行检查，如果是有状态的解析过程，还会赋予单词意义</u>。

这个概念是理解词法作用域，及其名称来历的基础。

简单的说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。

```js
function foo(a){
    var b = a * 2
    function bar(c){
        console.log(a,b,c)
    }
    bar(b*3)
}
foo(2)
```

在这个例子中有三个逐级嵌套的作用域，为了帮助理解，可以将它们想象成几个逐级包含的气泡。

![image-20220323180949187](https://s2.loli.net/2022/03/23/c8zZGNfEaj7SroH.png)

- 最外面的是整个全局作用域，其实只有一个标识符：foo。
- 包含着 foo 所创建的作用域，其中有三个标识符： a、bar 和 b
- 包含着 bar 所创建的作用域，其中只有一个标识符： c

作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的，每个函数都会创建一个新的作用域气泡。

bar 的气泡完全被包在 foo 所创建的气泡中，唯一的原因是那里就是我们希望定义函数 bar 的位置。

### 查找

**作用域气泡的结构和互相之间的位置关系，给引擎提供了足够的位置信息，引擎用这些信息查找标识符的位置。**

在上一个代码片段中，引擎执行 console.log 声明，并查找 a、b 和 c 三个变量的引用。它首先从最内部的作用域，也就是 bar 函数的作用域气泡开始查找。引擎无法在这里找到 a，因此会去上一层所嵌套的 foo 的作用域中继续查找，在这里找到了 a，因此引擎使用了这个引用。对 b 来说也是一样的。而对 c 来说，引擎在 bar 中就找到了它。

如果 a、c 都存在于 bar 和 foo 的内部，console.log 就可以直接使用 bar 中的变量，而无需去 foo 中查找。

作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中可以定义同名的标识符，这叫做**「遮蔽效应」，内部的标识符遮蔽了外部的标识符。**抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

**<u>无论函数在哪里被调用，也无论如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</u>**

> 注：这点很重要，这对传递参数提供了无数可能。

词法作用域只会查找一级标识符，比如 a、b 和 c。**如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管 bar 和 baz 属性的访问。**

### 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来修改词法作用域呢？

JavaScript 有两种机制来实现这个目的。**社区普遍认为在代码中使用这两种机制并不是什么好主意，因为：欺骗词法作用域会导致性能下降。**

在了解性能问题之前，先来看看这两种机制分别是什么原理。

#### eval

JavaScript 的 eval 函数可以接收一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像是写在那个位置一样。

根据这个原理来理解 eval，它是如何通过代码欺骗和假装书写时代码就在那儿，来实现修改词法作用域环境的？

在执行 eval 之后的代码时，引擎并不「知道」前面的代码是以动态的形式插入进来的，引擎只会如往常地进行词法作用域查找。

```js
function foo(str,a){
    eval(str) //欺骗
    console.log(a, b)
}

var b = 2
foo('var b = 3',1) // 1, 3
```

eval 调用中的 'var b = 3'，这段代码会被当作它们本来就在那里一样处理。由于那段代码声明了一个新的变量，因此它对已经存在的 foo 的词法作用域进行了修改。事实上，和前面提到的原理一样，这段代码实际上在 foo 内部创建了一个变量 b，并遮蔽了外部作用域中的同名变量。

当 console.log 被执行的时候，会在 foo 的内部同时找到 a 和 b，但是永远也无法找到外部的 b，因此会输出 1 3，而不是正常情况下的 1 2。

默认情况下，如果 eval 中所执行的代码包含有一个或多个声明，就会对 eval 所处的词法作用域进行修改。技术上，通过一些技巧可以间接调用 eval 来使其运行在全局作用域中， 并对全局作用域进行修改。

JavaScript 中还有一些功能效果和 eval 很相似，setTimeout 和 setInterval 中第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时并不被提倡。

new Function 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态的函数，这种构建函数的语法比 eval 略微安全一些，但也要尽量避免使用。

在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损耗。

#### with

JavaScript 中另一个难以掌握的用来欺骗词法作用域的功能是 with 关键字。可以有很多的方法来解释 with，在这里我选择从这个角度来解释它：*它如何同被它所影响的词法作用域进行交互。*

**with 通常被当作重复引用同一个对象中的的多个属性的快捷方式，可以不需要重复引用对象本身。**

比如：

```js
var obj = {
    a:1,
    b:2,
    c:3
}
// 单调乏味的重复 obj
obj.a = 2;
obj.b = 3
obj.c = 3

// 简单快捷的方式
with(obj){
    a = 3
    b = 4
    c = 5
}
```

但实际上，这不仅仅是为了方便的访问对象属性。

```js
function foo(obj) {
    with(obj) {
        a = 2
    }
}

var o1 = {
    a:3
}
var o2 = {
    b:3
}

foo(o1)
console.log(o1) // Object { a: 2 }
foo(o2)
console.log(o2) // Object { b: 3 }

console.log(a)// a 被泄漏到全局作用域上了！
```

在这个例子中创建了 o1 和 o2 两个对象，其中一个具有 a 属性，另外一个没有。foo 函数接受了一个 obj 参数，该参数是一个对象的引用，并对这个对象执行了 with 方法。

在 with 内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用，并将 2 赋值给它。

> LHS 查找如果最终没有找到，会在全局作用域里面创建一个。

当我们将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console.log 中可以得到体现。而当 o2 传递进去， o2 并没有 a 属性，因此不会创建这个属性，o2.a 保持 undefined。

但是注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a，这是怎么回事？

**with 可以将一个没有属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。**

**eval 函数如果接受了含一个声明的代码，就会修改其所处的词法作用域，而 <u>with 声明实际上是根据你传递给它的对象，凭空创建了一个全新的词法作用域</u>。**

可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中包含有一个同 o1.a 属性的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常 LHS 标识符查找。

**o2 的作用域、foo 的作用域和全局作用域都没有找到标识符 a，因此当 a = 2 执行时，自动地创建了一个全局变量。**

with 这种将对象及其属性放进一个作用域并同时分配标识符的行为很令人费解。

### 性能

eval 和 with 会在运行时修改或创建新的作用域，以此欺骗其他在书写时定义的词法作用域。

你可能会问，那又怎么样呢？如果它们能实现更复杂的功能，并且代码更具有扩展性，难道不是非常好的功能吗？

答案是否定的。

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码词法进行静态分析，并预先确定所有变量和函数定义的位置，才能在执行过程中快速找到标识符。

但如果在引擎代码中发现了 eval 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新的词法作用域对象的内容到底是什么。

**最悲观的情况是如果出现了 eval 或 with，所有的优化可能都是无意义的，因此最简单的方式就是完全不做任何优化。**

如果代码中大量使用了 eval 或 with，那么运行起来一定非常的缓慢。**无论引擎多聪明，试图将这些悲观的情况限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。**

