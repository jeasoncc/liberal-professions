到现在为止，你应该已经很熟悉作用域的概念，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：**任何声明在某个作用域内的变量，都将属于这个作用域。**

但是作用域同其中的变量声明出现的位置是有某种微妙的联系。

## 先有的鸡还是先有的蛋

直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上不并不完全正确，有一种特殊情况会导致这个假设是错误的。

考虑以下代码：

```js
a = 2
var a 
console.log(a)
```

你认为 console.log 声明会输出什么呢？

很多开发者会认为是 undefined，因为 var a 声明在 a = 2 之后，他们自然的认为变量被重新赋值了，因此会被赋予默认值 undefined。但是，真正的输出结果却是 2。

考虑另外一段代码：

```js
console.log(a)
var a = 2
```

鉴于上一个代码片段所表现出现的某种非自上而下的特点，你可能会认为这个代码片段也会有同样的行为而输出 2,还有人可能认为变量 a 在使用前没有先进行声明，因此会抛出 ReferenceError 异常。

不幸的是这两种猜测都是不对的，输出的会是 undefined。

那么到底发生到了什么？

到底是声明在前，还是赋值在前？

## 编译器再度来袭

为了搞明白这个问题，我们需要回忆下编译器的内容。引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。也正是词法作用域的核心内容。

**因此，正确的思路是，包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。**

<u>当你看到 var a = 2 时，可能会认为这是一个声明，但 JavaScript  实际上会将其看作是两个声明：var a 和 a = 2。**第一个声明是在编译阶段进行的，第二个声明会留在原地等待执行阶段。**</u>

我们的第一个代码片段会在如下阶段进行处理：

```js
var a
a = 2
console.log(a)
```

其中一部分是编译，而第二部分是执行。

类似地，我们的第二个代码片段实际上是按照如下的流程进行处理的：

```js
var a;
console.log(a)
a = 2
```

<u>因此，这个过程就好像变量和函数声明从它们代码中出现的位置被移动到了最上面，这个过程就叫做**提升**。</u>

另外需要值得注意的是，每个作用域都会进行提升操作。

```js
foo()

function foo(){
    console.log(a) // undefined 
    var a = 2
}
```

上面这段代码实际上会被理解为下面的形式:

```js
function foo() {
    var a;
    console.log(a) // undefined
    a = 2
}
foo()
```

**而且，函数声明会被提升，但函数表达式却不不会。**

```js
foo() // 不是 ReferenceError，而是 TypeError
var foo = function bar() {
    //
}
```

这段程序中的变量标识符 foo 被提升并分配给所有的作用域，因此 foo 不会导致 ReferenceError。但是 foo 此时并没有被赋值，foo() 对 undefined 进行函数调用而导致非法操作，因此会抛出 TypeError 异常。

**同时也要基记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。**

```js
foo() // TypeError
bar() // ReferenceError

var foo = function bar(){
    
}
```

这个代码片段经过提升后，实际上会被理解为以下的形式：

```js
var foo

foo() // TypeError
bar() // ReferenceError

foo = function(){
    
}
```

## 函数优先

函数声明和变量声明都会被提升，但是一个值得注意的细节是<u>函数会首先被提升，然后才是变量。</u>

考虑以下代码：

```js
foo() // 1
var foo

function foo() {
	console.log(1)    
}

foo = function() {
    console.log(2)
}
```

注意，var foo 尽管出现在 function foo(){……} 之前，但它是重复的声明，因此被忽略了。因为函数声明会被提升到普通变量之前。

**尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。**

```js
foo() // 3
function foo() {
    console.log(1)
}

var foo = function(){
    console.log(2)
}

function foo()  {
    console.log(3)
}
```

虽然这些听起来都是些无用的学院理论，但是它说明了同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。

<u>一个普通块的函数声明通常会被提升到所在作用域的顶部</u>，这个过程不会像下面代码暗示的那样被条件判断所控制。

```js
foo() // b
var a = true
if(a){
    function foo(){
        console.log('a')
    }
} else {
    function foo() {
        console.log('b')
    }
}
```

这个行为并不可靠，在 JavaScript 未来版本有可能发生改变，因此应该尽量避免在块内部声明函数。

## 小结

我们习惯将 var a = 2 看作是一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 看作是两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。

这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行首先被进行处理。

**可以将这个过程形象地想象为所有的声明都会被移动到各自作用域的最顶端，这个过程被称为提升。**

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。

要避免重复声明，特别是当普通的 var 声明和函数声明混在一起的时候，否则会被清除或覆盖。

​	