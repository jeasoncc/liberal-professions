# 对象

## 语法

对象可以通过两种形式定义：声明（文字）形式和构造形式。

对象的文字语法大概是这样：

```js
var myObj = {
    key: value
}
```

构造形式大概是这样：

```js
var myObje = new Object()
myObj.key = value
```

构造形式和文字形式的对象是一样的。<u>唯一的区别是，在文字声明中你可以添加多个键/值对，但是在构造形式中你必须逐个添加属性。</u>

## 类型

对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型：

- string
- number
- boolean
- null
- undefined
- object

注意，简单基本类型本身并不是对象。简单基本对象：

- string
- number
- boolean
- undefined
- null

null 有时会被当作是一种对象类型，但是这其实是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 'object'。实际上，null 本身是基本类型。

有一种常见的错误说法是「JavaScript 中万物皆是对象」，这显然是错误的。

实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。

函数就是对象的一个子类型。JavaScript 中函数是「一等公民」，因为它们的本质上和普通的对象是一样的，所以可以像操作其他对象一样操作函数，比如当作另一个函数的参数。

数组也是对象的一种类型，具备一些额外的行为。数组中的内容的组织方式比一般对象要稍微复杂一些。

### 内置对象

JavaScript 中还有一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂。

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

这些内置对象从表现形式来说很像其他语言中的 类型(type) 或者 类(class)，比如 Java 中的 String 类。

但是在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象。

```js
var str = 'i am a string'
typeof str // 'string'
str instanceof String // false

var strObj = new String('i am a string')
typeof strObj // 'object'
strObj instanceof String // true

Object.prototype.toString.call( strObj ) // '[object String]'
```

在之后的章节我们会详细介绍 Object.prototype.toString 是如何工作的，不过简单来说，我们可以认为子类型在内部借用了 Object 中的 toString() 方法。从代码中可以看到，strObj 是由 String 构造函数创建的一个对象。

<u>原始值 'i am a string' 并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度，访问其中某个字符等，那需要将其转换为 String 对象。</u>

幸好**，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要显式创建一个对象。** <u>JavaScript 社区中的大多数人都认为使用文字形式时就不要使用构造形式。</u>

思考下面的代码：

```js
var str = 'i am a string'
typeof str // 'string'
str instanceof String // false

var strObj = new String('i am a string')
typeof strObj // 'object'
strObj instanceof String // true

Object.prototype.toString.call( strObj ) // '[object String]'

console.log(str.length) // 13
console.log(strObj.length) // 13

console.log(str.charAt( 3 )) // m
console.log(strObj.charAt( 3 )) // m
```

使用以上两种方法，我们可以直接在字符串字面量上面访问属性或者方法，之所以可以这样做，是因为引擎自动地把字面量替换为 String 对象，所以可以访问属性和方法。

同样事也会发生在数字字面量上面。

<u>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Data 只有构造，没有文字形式。</u>

对于 Object、Array、Function 和 RegExp 来说，无论使用文字形式还是构造形式创建对象，它们都是对象，不是字面量。

在某些情况下，相比于用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所有我们首选更简单的文字形式。建议只需要那些额外选项时使用构造形式。

Error 对象很少在代码中被创建，一般是在抛出异常时被自动创建。也可以使用 new Error() 这种构造形式来创建，不过一般来说用不着。

## 内容

之前我们提到过，对象的内容是由一些存储在特定命名位置的值组成的，我们称之为属性。

<u>需要强调的一点是，当我们说「内容」时，似乎在暗示着这些值被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般不会存在对象容器的内部。存储在对象容器内部的是这些属性的名称，它们就像是指针一样。指向这些值真正存储的位置。</u>

```js
var obj = {
  a: 2
}

obj.a // 2

obj.['a'] // 2
```

如果要访问 obj 中 a 的位置，我们需要使用，操作符或者 [] 操作符。

**.a 语法通常被称为「属性访问」，['a']语法通常被称为「键访问」。**实际上它们访问的是同一个位置，并且会返回相同的属性 2,所以这两个术语是可以互换的。

**这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 ['..'] 语法可以接受任何 UTF-8/ Unicode 字符串作为属性名**。举例来说，如果要引用名称为 'super-fun' 的名称，那就必须使用 ['super-fun'] 语法访问，因为 super-funbk 并不是一个有效的标识符属性名。

此外，由于 ['..'] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：

```js
var obj = {
    a: 2
}
var idx;

if(true) {
    idx = 'a'
}

console.log( obj[idx] ) // 2
console.log( idx ) // 'a'
```

<u>**在对象中，属性名永远都是字符串**。如果你使用 string 以外的其他值作为属性名，那它首先会被转换成一个字符串。即使是数字也不例外，虽然在数字下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串</u>，所以要当心不要搞混对象和数组中数字的用法。

```js
var obj = {}

obj[true] = 'foo'
obj[3] = 'bar'
obj[obj] = 'baz'

obj['true']  
obj[3]
obj["[object Object]"]

// 'foo'
// 'bar'
// 'baz'
```

### 可计算属性名

如果你需要通过表达式来计算属性名，那么我们刚刚降到的 obj[..] 这种属性访问语法就可以派上用场了，如可以使用 obj[prefix + name]。但是使用文字形式来声明对象时这样做是不行的。

ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名。

```js
var prefix = 'foo'
var obj = {
  [prefix + 'baz']: 'hello',
  [prefix + 'bar']: 'world'
}

obj['foobar']
obj['foobaz']

// 'world'
// 'hello'
```

可计算属性名最常用的场景可能是 ES6 的符号 Symbol，这里不做介绍。

### 属性与方法

如果访问的对象属性是一个函数，有些开发者使用不一样的叫法以作区分。由于函数很容易被认为是属于某个对象，在其他语言中，属于对象的函数通常被称为「方法」，因此把「属性对象」说成是「方法访问」也就不奇怪了。

有意思的是，JavaScript 的语法规范也做出了同样的区分。

<u>从技术角度来说，函数永远不会「属于」一个对象，所以把对象内部称为「方法」似乎有些不妥。</u>

**确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个方法，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。**

无论返回值是什么类型，<u>每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它并不是一个「方法」。属性访问返回的函数和其他的函数并没有什么区别。</u>

```js
function foo() {
  console.log( 'foo' )
}

var someFoo = foo // 对 foo 的变量的引用

var obj = {
  someFoo: foo
}

foo 
someFoo
obj.someFoo

// ƒ foo()
// ƒ foo()
// ƒ foo()
```

someFoo 和 obj.someFoo 只是对同一个函数的不同引用，并不能说明这个函数是特别的或者「属于」某个对象。如果 foo 定义时在内部有一个 this 引用，那这两个函数引用的唯一区别就是 obj.someFoo 的 this 会被绑定到一个对象。*无论引用哪种形式都不能称之为「方法」。*

*或许有人会辩解说，函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同成为方法。即便如此，这种说法仍然有些不妥。*

<u>最保险的说法可能是：「函数」和「方法」在 JavaScript 中是可以互换的。</u>

即使你在对象的文字形式中声明了一个函数表达式，这个函数也不会「属于」这个对象——它们只是对于相同函数对象的多个引用。

```js
var obj = {
  foo: function() {
    console.log( 'foo' )
  }
}

var someFoo = obj.foo

someFoo
obj.foo

// ƒ foo()
// ƒ foo()
```

### 数组

数组也支持 [] 访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制。<u>数组期望的是数值下标，也就是说值存储的位置是整数。</u>

```js
var array = ['foo', 32, 'bar']
array.length
array[0]
array[2]

// 3
// 'foo'
// 'bar'
```

**数组也是对象，所以虽然每个下标都是整数，你仍然可以被数组添加属性：**

```js
var array = ['foo', 32, 'bar']

array.baz = 'baz'

array.length // 3

array.baz // 'baz'

array['baz'] // 'baz'
```

可以看到虽然添加了命名属性，（无论是通过 · 语法还是 [] 语法），数组的 length 值并未发生变化。

**你完全可以把数组当作是一个普通的键/值对象使用，并且不添加任何数值索引，但是这并不是一个好主意。**<u>数组和普通的对象根据其对应的行为和用途进行了优化，所以最好只用对象来存储键/值对，只用数组来存储数值下标/值对。</u>

<u>注意：如果你试图向数组添加一个属性，但是属性名「看起来」像一个数字，那它会变成一个数值下标，因此会修改数组的内容而不是添加一个属性。</u>

```js
var array = ['foo', 32, 'bar']

array['3'] = 'baz'

array.length // 4 

array[3] // 'baz'
```

### 复制对象

JavaScript 初学者最常见的问题之一就是如何复制一个对象。看起来应该有一个内置的 copy() 方法？实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。

思考一下这个对象：

```js
function anotherFn() {
}

var anotherObj = {
  c: true
}

var anotherArray = []

var myObj = {
  a: 2,
  b: anotherObj, // 引用，不是复制！
  c: anotherArray, // 另一个引用
  d: anotherFn
}

anotherArray.push( anotherObj, myObj )
```

如何准确地表示 myObj 的复制呢？

首先，我们应该判断它是<u>浅复制</u>还是<u>深复制</u>。

对于浅复制来说，复制出的新对象中的 a 的值会复制旧对象 a 的值，也就是 2，但是新对象中的 b、c、d 三个属性其实只是三个引用，它们和旧对象中 b、c、d 引用的对象是一样的。

对于深复制来说，除了 myObj 以外还会复制 anotherObj 和 anotherArray。这时问题就来了，anotherArray 引用了 anotherObj 和 myObj，所以又需要复制 myObj，这样就会由于循环引用导致死循环。

我们是应该检测循环并终止循环？还是应该直接报错或是选择其他方法？

除此之外，我们还不确定「复制」一个函数意味着什么。有些人会通过 toString() 来序列化一个函数的代码。

那么如何解决这些棘手问题呢？许多 JavaScript 框架都提出了自己的解决办法，但是 JavaScript 应当采取哪种方法作为标准呢？在很长一段时间里，这个问题都没有明确的答案。

对于 JSON 安全的对象来说，有一个巧妙的复制方法。	

```js
var newObj = JSON.parse(
  JSON.stringify( someObj )
)
```

当然，这种方法需要保证对象是 JSON 安全的，所以只适用于部分情况。

<u>相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign 方法来实现浅复制。 Object.assign 方法是第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个对象的所有枚举对象的自有键并把它们复制到目标对象，最后返回目标对象</u>，就像这样：

```js
function anotherFn() {
}

var anotherObj = {
  c: true
}

var anotherArray = []

var myObj = {
  a: 2,
  b: anotherObj, // 引用，不是复制！
  c: anotherArray, // 另一个引用
  d: anotherFn
}

anotherArray.push( anotherObj, myObj )

var newObj = Object.assign( {}, myObj )

newObj.a; // 2
  
newObj.b // { c: true }
newObj.c 
// [
//   { c: true },
//   { a: 2, b: { c: true }, c: [Circular *1], d: ƒ anotherFn() }
// ]
newObj.d // ƒ anotherFn()
```

### 属性描述符

在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。

但是从 ES5 开始，所以的属性都具备了属性描述符。

思考下面的代码：

```js
var myObj = {
  a: 2
}

Object.getOwnPropertyDescriptor( myObj, 'a' )

// { value: 2, writable: true, enumerable: true, configurable: true }
```

如你所见，这个普通的对象属性对应的属性描述符可不仅仅只是一个 2，它还包含三个特性：writable(可写)、enumerable(可枚举) 和 configurable(可配置)。

来创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty 来创建一个新属性或者修改一个已有属性，如果它是 configurable 并对特性进行设置。

```js
var obj = {}

Object.defineProperty( obj, 'a', {
  value: 2,
  writable: true,
  configurable: true,
  enmerable: true
})

obj.a // 2
```

我们使用 defineProperty 给 obj 添加了一个普通属性并显示指定了一些特性。然而，一般来说你不会使用这种方式，除非你想修改属性描述符

#### Writable

writable 决定是否可以修改属性的值。

````js
var obj = {}

Object.defineProperty( obj, 'a', {
  value: 2,
  writable: false,
  configurable: true,
  enmerable: true
})

obj.a // 2

obj.a = 3

obj.a // 2
````

如你所见，我们对于属性值的修改静默失败了。如果在严格模式下，这种方法会出错：

```js
"use strict";
var obj = {}

Object.defineProperty( obj, 'a', {
  value: 2,
  writable: false,
  configurable: true,
  enmerable: true
})

obj.a // 2

obj.a = 3 // TypeError: Cannot assign to read only property 'a' of object

obj.a // 2
```

#### Configurable

只要属性是可配置的，就可以使用 defineProperty 方法来修改属性描述符：

```js
var obj = {
    a: 2
  };
  
  obj.a = 3;
  obj.a // 3
  
  Object.defineProperty(obj, 'a', {
    value: 4,
    writable: true,
    configurable: false, //  不可配置
    enmerable: true,
  });
  
  obj.a // 4
  obj.a = 5
  obj // 5
  
  Object.defineProperty(obj, 'a', {
    value: 6,
    writable: true,
    configurable: true,
    enmerable: true,
  }); // TypeError: Cannot redefine property: a
```

最后一个 defineProperty 会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。注意：如你所见，把 configuralbe修改成 false 是单向操作，无法撤销！

除了无法修改，configurable:false 还会禁止删除这个属性：

```js
var obj = {
  a: 2
};

obj.a = 3;
obj.a // 3

Object.defineProperty(obj, 'a', {
  value: 4,
  writable: true,
  configurable: false, //  不可配置
  enmerable: true,
});

obj.a // 4
obj.a = 5
obj // 5

delete obj.a

obj.a // 5
```

如你所见，最后一个 delete 语句失败了，因为属性是不可配置的。

<u>在本例中，delete 只用来直接删除对象的可删除属性，如果对象的某个属性是某个对象/函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象/函数就可以被垃圾回收。</u>但是，不要把 delete 看作是一个释放内存的工具，它就是一个删除对象属性的操作，仅此而已。

#### Enumerable

这里我们要介绍最后一个属性描述符是 enumerable。

从名字就可以看出来，这个描述符控制的是属性是否会出现在对象的属性枚举中，比如 for in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。

用户定义的所有普通属性默认都是 enumuerable，这通常就是你想要的。但是如果你不希望某些特殊属性出现在枚举中，那就把它设置成 enumerable: false。

### 不变性

有时候你会希望属性或者对象是不可变的，在 ES5 中可以通过很多中方法来实现。

很重要的一点是，<u>所有的方法创建都是浅不变形，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象，其他对象的内容不受影响，仍然是可变的。</u>

#### 对象常量

结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、冲	
