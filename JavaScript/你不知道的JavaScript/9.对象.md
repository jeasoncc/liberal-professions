# 对象

## 语法

对象可以通过两种形式定义：声明（文字）形式和构造形式。

对象的文字语法大概是这样：

```js
var myObj = {
    key: value
}
```

构造形式大概是这样：

```js
var myObje = new Object()
myObj.key = value
```

构造形式和文字形式的对象是一样的。<u>唯一的区别是，在文字声明中你可以添加多个键/值对，但是在构造形式中你必须逐个添加属性。</u>

## 类型

对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型：

- string
- number
- boolean
- null
- undefined
- object

注意，简单基本类型本身并不是对象。简单基本对象：

- string
- number
- boolean
- undefined
- null

null 有时会被当作是一种对象类型，但是这其实是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 'object'。实际上，null 本身是基本类型。

有一种常见的错误说法是「JavaScript 中万物皆是对象」，这显然是错误的。

实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。

函数就是对象的一个子类型。JavaScript 中函数是「一等公民」，因为它们的本质上和普通的对象是一样的，所以可以像操作其他对象一样操作函数，比如当作另一个函数的参数。

数组也是对象的一种类型，具备一些额外的行为。数组中的内容的组织方式比一般对象要稍微复杂一些。

### 内置对象

JavaScript 中还有一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂。

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

这些内置对象从表现形式来说很像其他语言中的 类型(type) 或者 类(class)，比如 Java 中的 String 类。

但是在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象。

```js
var str = 'i am a string'
typeof str // 'string'
str instanceof String // false

var strObj = new String('i am a string')
typeof strObj // 'object'
strObj instanceof String // true

Object.prototype.toString.call( strObj ) // '[object String]'
```

在之后的章节我们会详细介绍 Object.prototype.toString 是如何工作的，不过简单来说，我们可以认为子类型在内部借用了 Object 中的 toString() 方法。从代码中可以看到，strObj 是由 String 构造函数创建的一个对象。

<u>原始值 'i am a string' 并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度，访问其中某个字符等，那需要将其转换为 String 对象。</u>

幸好**，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要显式创建一个对象。** <u>JavaScript 社区中的大多数人都认为使用文字形式时就不要使用构造形式。</u>

思考下面的代码：

```js
var str = 'i am a string'
typeof str // 'string'
str instanceof String // false

var strObj = new String('i am a string')
typeof strObj // 'object'
strObj instanceof String // true

Object.prototype.toString.call( strObj ) // '[object String]'

console.log(str.length) // 13
console.log(strObj.length) // 13

console.log(str.charAt( 3 )) // m
console.log(strObj.charAt( 3 )) // m
```

使用以上两种方法，我们可以直接在字符串字面量上面访问属性或者方法，之所以可以这样做，是因为引擎自动地把字面量替换为 String 对象，所以可以访问属性和方法。

同样事也会发生在数字字面量上面。

<u>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Data 只有构造，没有文字形式。</u>

对于 Object、Array、Function 和 RegExp 来说，无论使用文字形式还是构造形式创建对象，它们都是对象，不是字面量。

在某些情况下，相比于用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所有我们首选更简单的文字形式。建议只需要那些额外选项时使用构造形式。

Error 对象很少在代码中被创建，一般是在抛出异常时被自动创建。也可以使用 new Error() 这种构造形式来创建，不过一般来说用不着。

## 内容

之前我们提到过，对象的内容是由一些存储在特定命名位置的值组成的，我们称之为属性。

<u>需要强调的一点是，当我们说「内容」时，似乎在暗示着这些值被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般不会存在对象容器的内部。存储在对象容器内部的是这些属性的名称，它们就像是指针一样。指向这些值真正存储的位置。</u>

```js
var obj = {
  a: 2
}

obj.a // 2

obj.['a'] // 2
```

如果要访问 obj 中 a 的位置，我们需要使用，操作符或者 [] 操作符。

**.a 语法通常被称为「属性访问」，['a']语法通常被称为「键访问」。**实际上它们访问的是同一个位置，并且会返回相同的属性 2,所以这两个术语是可以互换的。

**这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 ['..'] 语法可以接受任何 UTF-8/ Unicode 字符串作为属性名**。举例来说，如果要引用名称为 'super-fun' 的名称，那就必须使用 ['super-fun'] 语法访问，因为 super-funbk 并不是一个有效的标识符属性名。

此外，由于 ['..'] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：

```js
var obj = {
    a: 2
}
var idx;

if(true) {
    idx = 'a'
}

console.log( obj[idx] ) // 2
console.log( idx ) // 'a'
```

<u>**在对象中，属性名永远都是字符串**。如果你使用 string 以外的其他值作为属性名，那它首先会被转换成一个字符串。即使是数字也不例外，虽然在数字下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串</u>，所以要当心不要搞混对象和数组中数字的用法。

```js
var obj = {}

obj[true] = 'foo'
obj[3] = 'bar'
obj[obj] = 'baz'

obj['true']  
obj[3]
obj["[object Object]"]

// 'foo'
// 'bar'
// 'baz'
```

### 可计算属性名

如果你需要通过表达式来计算属性名，那么我们刚刚降到的 obj[..] 这种属性访问语法就可以派上用场了，如可以使用 obj[prefix + name]。但是使用文字形式来声明对象时这样做是不行的。

ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名。

```js
var prefix = 'foo'
var obj = {
  [prefix + 'baz']: 'hello',
  [prefix + 'bar']: 'world'
}

obj['foobar']
obj['foobaz']

// 'world'
// 'hello'
```

可计算属性名最常用的场景可能是 ES6 的符号 Symbol，这里不做介绍。

### 属性与方法

如果访问的对象属性是一个函数，有些开发者使用不一样的叫法以作区分。由于函数很容易被认为是属于某个对象，在其他语言中，属于对象的函数通常被称为「方法」，因此把「属性对象」说成是「方法访问」也就不奇怪了。

有意思的是，JavaScript 的语法规范也做出了同样的区分。

<u>从技术角度来说，函数永远不会「属于」一个对象，所以把对象内部称为「方法」似乎有些不妥。</u>

**确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个方法，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。**

无论返回值是什么类型，<u>每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它并不是一个「方法」。属性访问返回的函数和其他的函数并没有什么区别。</u>

```js
function foo() {
  console.log( 'foo' )
}

var someFoo = foo // 对 foo 的变量的引用

var obj = {
  someFoo: foo
}

foo 
someFoo
obj.someFoo

// ƒ foo()
// ƒ foo()
// ƒ foo()
```

someFoo 和 obj.someFoo 只是对同一个函数的不同引用，并不能说明这个函数是特别的或者「属于」某个对象。如果 foo 定义时在内部有一个 this 引用，那这两个函数引用的唯一区别就是 obj.someFoo 的 this 会被绑定到一个对象。*无论引用哪种形式都不能称之为「方法」。*

*或许有人会辩解说，函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同成为方法。即便如此，这种说法仍然有些不妥。*

<u>最保险的说法可能是：「函数」和「方法」在 JavaScript 中是可以互换的。</u>

即使你在对象的文字形式中声明了一个函数表达式，这个函数也不会「属于」这个对象——它们只是对于相同函数对象的多个引用。

```js
var obj = {
  foo: function() {
    console.log( 'foo' )
  }
}

var someFoo = obj.foo

someFoo
obj.foo

// ƒ foo()
// ƒ foo()
```

### 数组

