## [[Prototype]]

JavaScript 中几乎所有属性都有一个 [[Prototype]] 内置属性，其实就是一个对于其他对象的引用。几乎所有的对象都在创建时 [[Prototype]] 属性都会被赋予一个非空的值。

> JavaScript 中所有的对象都存在一个 [[Prototype]] 属性，而且它的 [[Prototype]] 是非空的。

注意：我们很快就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见。

> [[Prototype]] 一般是不为空的，但是可以人工的置为空。

思考下面的代码：

```js
var myObj = {
  a: 2
}

myObj.a  // 2
```

> 这段代码通过字面量的方式定义了一个对象，然后访问到了这个对象的属性。作者在这里拿出这个例子来，是想说明一般是不会访问到 [[Prototype]] 属性的。

[[Prototype]] 引用有什么用呢？我们以前说过，当你试图访问一个对象的属性的时候会触发 [[Get]] 操作，比如 myObj.a。对于默认的 [[Get]] 操作来说，第一步是检查对象本身是否具有这个属性，如果有的话就使用它。

> 这里的知识点是关于访问对象属性的时候，会触发对象的 [[Get]] 操作，这个方法是隐藏的。

但是如果 a 不在 myObj 中，就需要使用对象的 [[Prototype]] 链了。

对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链。

> 这里提到了 [[Prototype]] 链，以及查找对象属性的方式，当对象本身并不具有某个属性的时候，就开始在 [[Prototype]] 链上查找。

```js
var anotherObj = {
  a: 2
}

var myObj = Object.create( anotherObj )
myObj.a //2
```

稍后我们会介绍 Object.create 的原理，现在只需要知道它会创建一个对象并把这个对象的 [[Prototype]] 关联到指定对象上。

> 这段代码通过关联原型的方式，来进行属性的访问，可以看到  myObj 并没有指定任何属性，此时 a 属性是访问的原型链上的 anotherObj 的 a 属性。

现在 myObj 对象的 [[Prototype]] 关联到 anotherObject。显然 myObj.a 并不存在，但是尽管如此，属性访问仍然成功地找到了值 2。

<u>但是，如果 anotherObj 中什么也不到 a 并且 [[Prototype]] 链不为空的话，就会继续查找下去。</u>

**这个过程会持续找到匹配的属性名或者查找完整条 [[Prototype]] 链。**<u>如果是后者的话， [[Get]] 操作的返回值是 undefined。</u>

<u>使用 for in 遍历对象时原理和查找 [[Prototype]] 链类似，任何通过原型链</u>访问到的属性都会被枚举。<u>**使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象整条原型链，无论属性是否可枚举**。</u>

> in 操作符作用于整条原型链。并且原型链的查找会在找到时就停止，找不到的话就持续到原型链的最后一层。
>
> in 操作符用来确定当前字符串的属性名是否存在于指定对象的原型链条上。

```js
var anotherObj = {
  a: 2,
  b: 2
}

var myObj = Object.create( anotherObj )
myObj.c =12

for(var k in myObj){
  console.log('found:' + k)
}

// 'found:c'
// 'found:a'
// 'found:b'

('a' in myObj); // true

console.log(myObj.d) // undefined
```

> 这里的代码是分别表现了原型绑定，in 操作符，查找不到的会最后输出 undefined。

因此，当你通过各种语法进行属性查找时都会查找 [[Prototype]] 链，直到找到属性或者查找完整条原型条。

### Object.prototype

但是到哪里事是 [[Prototype]] 的「尽头」呢？

所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。由于所有的「普通」对象都「源于」这个 Object.prototype 对象，所以它包含了 JavaScript 中许多通用的功能。

> 所有的原型链的最外层都是 Object.prototye，这是 JavaScript 对象的基本功能。

有些功能你应该已经很熟悉了，比如说 toString 和 valueOf，以及之前介绍的 hasOwnPrototype。稍后我们还会介绍 isPrototypeOf，这个你可能不太熟悉。

### 属性设置和屏蔽

给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。现在我们完整地讲解一下这个过程。

```js
myObj.foo = 'bar'
```

如果 myObj 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有属性值。

如果 foo 不直接存在于原型链的上层，赋值语句 myObj.foo = 'bar' 行为就会有些不同，而且可能出乎意料。

<u>如果属性名 foo 既出现走 myObj 中也出现在 myObj 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObj 中包含的 foo 属性会屏蔽原型链上层所有的 foo 属性，因为 myObj.foo 总会选择原型链中最底层的 foo 属性。</u>

> 原型链有就近原则，当在附近找到时，就不会继续往上寻找。
>
> 这里的屏蔽一词的意思是指：不再继续查找。

屏蔽比我们想象的要复杂，下面我们分析一波如果 foo 不直接存在于 myObj 中而是存在原型链上层时 myObj.foo = 'bar' 的三种情况。

1. 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性，并且没有标记为只读，那就会直接在 myObj 中添加一个名为 foo 的新属性，它是屏蔽属性。
2. 如果在 [[Prototype]] 上层存在 foo，但是它被标记为只读，那么无法修改已有属性，或者在 myObj 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。
3. 如果在 [[Prototype]] 链上存在 foo，并且它是一个 setter，那就一定会调用这个 setter，foo 不会被添加到 myObj，也不会重新定义 foo 这个 setter。

大多数开发者都认为如果想 [[Prototype]] 链上层已经存在的属性 [[Put]] 赋值，就一定会触发屏蔽，但是如你所见，三种情况中只有第一种是这样的。

> 屏蔽属性是指存在于属性存在于对象本身，而不存在于整个原型链上。

> 在我看来，这里的三种情况，只有第一中是正常情况，第二种碰上的可能微乎其微，至于第三种，更是违反常规操作，开发这些年，从未见过不使用默认的 [[Get]] 和 [[Put]] 的，它只是为了表示知识的完整性，而深究于学院派的理论中。
>
> 至于作者为什么要在这么讲这些看似没用，其实也没用的知识，可能只是基于学院派的理论学习。但在恰恰就是目前互联网所需要的，作为一个日渐成熟的产业，这些讨论会被提出来，也是很正常的事情。

如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 = 操作符来赋值，而是使用

```js
var anotherObj = {
  a: 2,
  b: 2
}

var myObj = Object.create( anotherObj )
myObj.c =12

console.log(  myObj) // { c: 12, __proto__: { a: 2, b: 2 } }

myObj.a = 100
console.log(myObj) // { c: 12, a: 100, __proto__: { a: 100, b: 2 } }
```

```js
var anotherObj = {
  a: 2,
  b: 2
}
Object.defineProperty(anotherObj, 'foo', {
  value: 1000,
  writable: false
})
var myObj = Object.create( anotherObj )
myObj.foo = 100
console.log(myObj) // { __proto__: { a: 2, b: 2, foo: 1000 } }

Object.defineProperty(myObj, 'foo', {
  value: 1001,
  writable: true
})

console.log(myObj) // { foo: 1001, __proto__: { a: 2, b: 2, foo: 1001 } }
```

> 我在这里针对第一种情况，和第二种情况做了个案例，情况确实如书中所讲的那样。
>
> 如果 defineProperty 定义了原型中的属性，并且可写与修改设置 为 false，那么直接用 = 赋值不起作用，使用 defineProperty 才会起作用。但是事实上有谁会在代码里使用 defineProperty 来定义属性呢？究竟是在什么情况下，我才会去想想配置 writable configuable enmunable 这些参数呢？
>
> 很少会用上。

## 「类」

现在你可能很好奇：为什么一个对象需要关联到另一个对象呢？这样做有什么好处？这个问题非常好，但是在回答之前我们首先要理解 [[Prototype]] 不是什么？

> 为什么一个对象需要关联到另一个对象？这个问题我也想知道，因为就我目前的项目经验，用到原型的次数寥寥无几，好几次还是我强行加进去的。
>
> 在没有类以前，人们会把方法绑定在原型对象上，来达到节省内存的地步。
>
> 作者在这里自问自答，自肯定的写作手法，多少让人忍俊不禁，这个问题非常好？你自己提的吧！

以前我们说过，JavaScript 和面向类的语法不同，它并没有作为对象的抽象模式或者说蓝图。**JavaScript 中只有对象。**

> 这句话很重要，JavaScript 中只有对象。连数组都是个伪数组，是由对象假装而成的。函数也是一个对象。
>
> 基本类型连 null 都是一个对象。
>
> JavaScript 的基本类型 string nmber boolean undefined 不是对象。
>
> JavaScript 这门语言设计出来，本身就是作为脚本语言，是为了在一页中使用的，如今会去讨论设计蓝图的问题，也是因为它现在扮演着更为重要的角色，代码量也是极剧增加。

### 「类」函数

多年以来，JavaScript 中有一种奇怪的行为一直在被无耻的滥用，那就是模仿类。我们会仔细分析这种方法。

这种奇怪的「类似类」的行为利用了函数的一种特殊属性：所有函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象：

```js
function Foo() {
    
}
Foo.prototype // {}
```

<u>这个对象通常被称为 Foo 的原型</u>，因为我们通过名为 Foo.prototype 的属性引用来访问它。然而不幸的是，这个术语对我们造成极大的误导，稍后我们就会看到。如果是我的话就会叫它「之前被称为 Foo 的原型的那个对象。」

这个对象究竟是什么？

<u>最直接的解释就是，这个对象是在调用 new Foo() 时创建的，最后会被关联到这个 「Foo 点 prototype」对象上。</u>

> 我不明白它这句话的意思，这个对象是在调用 new Foo() 时创建的？
>
> 这似乎是说当在只有当调用 new 的时候，才会创建  prototype ，但是这个函数 Foo 被创建的时候，Foo.prototype 就已经存在了。
>
> 最后被关联到 foo 的 prototype 对象，这句话的意思是 new Foo() 创建的对象，和 Foo.prototype 是同一个对象吗？
>
> 这里的意思很不清晰，应该是翻译的问题。

```js
function Foo() {}
Foo.prototype = {a:121}
var a = new Foo()
// 获取 a 的原型对象
Object.getPrototypeOf( a ) // { a: 121 }
a // { __proto__: { a: 121 } }
```

> 似乎，a 的原型和 Foo 的原型对象是同一个。

调用 new Foo() 时会创建 a，其中的一步就是给 a 一个内部的 [[Prototype]] 链接，关联到 Foo.prototype 指向的那个对象。

暂停一下，仔细思考这条语句的含义。

> 给 a 一个内部 [[Prototype]] 链接，关联到 Foo.prototype 指向的那个对象？
>
> 为什么要说的这么拗口？
>
> <u>直接说明： a 的原型绑定在 Foo 的原型上，它不简单明了吗？</u>
>
> 这该死的翻译，傻逼！

在面向类的语言中，类可以被复制多次，就像用模具制作东西一样。我们以前看到过，之所以会这样是因为：实例化一个类就意味着「把类行为复制到物理对象中」，对于每一个实例都会重复这个过程。

> 实例化是对蓝图的实体化。妈的，你个傻逼翻译，写你妈呢？

但是在 JavaScript 中，并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们 [[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象并不会完全失去联系。它们是互相关联的。

> JavaScript 中并不存在真正的类，只有对象。相关的原型将这些对象联系在一起。

<u>new Foo() 会生成一个新对象，这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。</u>

> 这就是这所有小节的唯一论点，妈的，难道不应该直接抛出来吗？为什么要在中间写出来。。

最后我们得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，实际上我们并没有从「类」中复制任何行为到一个对象中，只是让两个对象相互关联。

> 类的数据结构是一个栈，而实例化是一个复制拷贝的过程。
>
> JavaScript 中并没有 栈 这个结构，而复制拷贝是对这个结构的模仿。
>
> 所以，JavaScript 中没有真正的类。只是对类行为的模仿。

实际上，绝大多数 JavaScript 开发人员都不知道的秘密是：new Foo() 这个函数调用实际上并没有直接关联，这个关联是一个意外的副作用。 <u>new Foo() 只是间接完成了我们的目标：一个关联到其他对象的新对象。</u>

> 一个关联到其他对象的新对象？
>
> 这句话是似乎是重点，但是你他妈在说尼玛呢？
>
> 一个新对象？关联其他对象？
>
> 这里的一个对象是指新创建的对象，这个对象的创建通过 new 创建，关联到其他对象也是 new 关键字的功能，将新对象和 Foo 对象进行绑定。

那么有没有更直接的方法来做到这一点呢？当然！功臣就是 Object.create，不过我们现在暂时不介绍它。

> 那人家都说不介绍了，咱就继续往下看呗。

#### 关于名称

在 JavaScript 中，我们并不会将一个对象复制到另一个对象，只是将它们关联起来。从视觉角度来说， [[Prototype]] 机制如下图所示，箭头从右到左，从下往上：

![image-20220413151203405](https://s2.loli.net/2022/04/13/b5IuKNtPqsMzwma.png)

这个机制通常被称为「原型继承」，它常常
