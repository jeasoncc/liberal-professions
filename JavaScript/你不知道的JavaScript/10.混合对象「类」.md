这章自然介绍和类相关的面向对象编程，研究类的具体机制之前，我们首先会介绍面向类的设计模式：实例化、继承和多态。

> 本章用很大的篇幅介绍了面向对象编程理论，在后半章介绍混入时会把这些概念到 JavaScript 代码上。但是首先我们看到许多概念和伪代码，因为千万不要迷路——跟紧了！

## 类理论

<u>类/继承描述了一种代码的组织结构形式——一种软件中对真实世界问题领域的建模方法。</u>

<u>面向对象编程强调的数据和操作数据的行为本质是互相关联的，因此好的设计就是把数据以及和它的行为打包起来。</u>这在正式的计算机科学中有时被称为数据结构。

举例来说，用来表示一个单词或者短语的一串字符通常被称为字符串。字符就是数据。但是你关心的往往不是数据是什么，而是可以对数据做什么，所以可以应用在这种数据上的行为都被设计成 String 类的方法。

所以字符串都是 String 类的一个实例，也就是说它是一个包裹，包含字符串和我们可以应用在数据上的函数。

我们来看一个常见的例子，「汽车」可以被看作「交通工具」的一种特例，后者是更广泛的类。

我们可以在软件中定义一个 Vehicle 类一个 Car 类来对这种关系进行建模。

Vehcle 的定义可能包含推进器（比如引擎）、载人能力等等，这些都是 Vehicle 的行为。我们在 Vehicle 中定义的是所有类型的交通工具都包含的东西

在我们的软件中，对不同的交通工具重复定义「载人能力」是没有多余的。相反，我们只需要在 Vehicle 中定义一次，定义 car 时，只要声明它继承了 Vehicle 的这个基础定义就行。Car 的定义就是对通用 Vehicle 定义的特殊化。

虽然 Vehicle 和 Car 会定义相同的方法，但是实例中的数据可能是不同的，比如每辆车有独一无二的车辆识别号码等等。

这就是类，继承和实例化。

<u>类的另一个核心是多态，这个概念我们可以说父类通用的行为可以被子类用更特殊的行为重写。</u>实际上，相对多态**性允许我们从重写行为中引用基础行为。**

类理论强烈建议父类和子类使用相同的方法名来定义特定的行为，从而让子类重写父类。<u>我们之后会看到，在 JavaScript 代码中这种做会降低代码代码的可读性和健壮性。</u>

> 介绍了类——一种结构化组织代码的形式。以及面向对象编程的几种性质：继承、实例化、多态。
>
> 以及一个新论点：多态在 JavaScript 表现并不优秀。

### 「类」的设计

你可能从来没有把类作为设计模式来看待，讨论的最多的是面向对象的设计模式，比如迭代器模式、观察者模式、工厂模式、单例模式等等。*从这个角度来说，我们似乎是在低级面向对象的基础上实现了所有高级设计模式，似乎面向对象是优秀代码的基础。*

> 提出质疑：面对对象是优秀代码的基础吗？

如果你以前接触过正规的编程教育的话，可能还会听说过「过程化编程」，这种代码只包含了过程函数的调用，没有高层的抽象。或许老师还教你最好使用类把过程化的「意大利面代码」转换成结构清晰，组织良好的代码。

> 明褒暗贬，作者似乎对面对对象编程和类编程是优秀代码规范这个观点，提出了自己的质疑

当然，如果你有函数式编程的经验就知道类也是一种非常常用的设计模式。**但是对于其他人来说，这可能是第一次知道类并不是必须的编程基础，而是一种可选的代码抽象。**

> 论点：面对对象只是一种可选择的抽象方式，并非最优解。

有些语言（比如 Java）并不会给你选择的机会，类并不是可选择的——万物皆是类。其他语言（C++）则会提供面向过程和面向类这两种语法，开发者可以选择其中的一种风格或混用两种风格。

> 介绍其他语言的 类 编程风格

### JavaScript 中的「类」

JavaScript 属于哪一类呢？在相当长的时间里，JavaScript 中只有一些近似类的语法元素（比如 new 和 instanceof），不过在后面的 ES6 中新增加了一些元素，比如 class 关键字。

这是不是意味着 JavaScript 中实际有类呢？简单来说：不是。

> 事实：JavaScript 中并不存在真正的类，只是模仿类的语法的设计模式。

由于类是一种设计模式，所以你可以用一些方法近似实现类的功能。为了满足类设计的最普遍需求，JavaScript  提供了一些近似类的语法。

> 只是为了满足设计模式，这是不是最优解并没有说明。

虽然有近似的语法，但是 JavaScript 的机制似乎一直在阻止你使用类设计模式。**在近似类的表象之下，JavaScript 的机制起初和类完全不同**。<u>语法糖和广泛使用的 JavaScript 类库试图掩盖这个事实，但是你迟早会面对它：**其他语言的类和 JavaScript 中的「类」不一样。**</u>

>JavaScript 中并不存在真正的类，它只是仿照类。

总结一下，在软件设计中类是一种可选的模式，你需要自己决定是否在 JavaScript 中使用它。由于许多开发者都非常喜欢面向类的软件设计，我们会在本章升剩余部分介绍如何在 JavaScript 中实现类以及存在的一些问题。

## 类的机制 

在许多面向类的语言中，「标准库」会提供 Stack 类，它是一种「栈」数据结构。Stack 类会有一些变量来储存数据，同时提供一些公开的可访问行为，从而让你的代码可以和数据进行交互。

> 面向类的语言中，类的本质是一种栈数据结构。

但是在这些语言中，你实际上并不直接操作 Stack。**Stack 类仅仅是一个抽象的表示，它描述了所有「栈」需要做的事，但是它本身并不是一个「栈」。**你必须先实例化 Stack 类然后才能对它进行操作。

### 建造

**「类」和「实例」的概念来自于房屋建造。**

<u>建筑师会规划出一个建筑的所有特性：多宽、多高、多少窗户以及窗户的位置，甚至连建造墙和房顶需要的材料都要计划好。</u>好在这个阶段他并不需要关心建筑会建在哪里，也不需要关心建造多少个这样的建筑。

建筑师也不关心建筑里的内容——家具、壁纸、吊扇等，他只需要关心用什么结构来容纳它们。

**建筑蓝图只是建筑计划，它们并不是真正的建筑，我们还需要一个建筑工人来建造建筑。**建筑工人会按照蓝图建造建筑。实际上，他会把规划好的特性从蓝图中复制到现实世界建筑中。

> 建筑师规划出类的特性，蓝图是设计本身的体现。

完成后，建筑就成为了蓝图的物理实例，本质上就是对蓝图的复制。之后建筑工人就可以到下一个地方，把所工作都重复了一遍，再创建一个副本。

> 建筑就是实例，蓝图是蓝图设计稿。

建筑和蓝图之间的关系是间接的。**你可以通过蓝图了解建筑的结构，对于建筑本身是无法获取这些信息的**。<u>但是如果你想打开一扇门，那就必须接触真实的建筑才行——蓝图只能表示门应该在哪，但并不是真正的门。</u>

> 蓝图只是一张纸，它不是真正的建筑。
>
> 蓝图可以了解建筑的整体结构，而建筑本身反映建筑的整体结构则需要反推理。
>
> 其实在编程做一个软件系统，写一本书、造一个房子，这些都是一样的，需要一个设计蓝图，然后根据蓝图来逐步完善。当然，作者在这里的蓝图仅仅指的是类的结构，在软件中更大的蓝图是软件系统的整体设计思路。

一个类就是一张蓝图，为了获得真正可交互的对象，我们必须按照类来建造一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问所有公有数据属性。

> 介绍实例

这个对象就是类中描述的所有特性的一个副本。

> 实例拥有类中所有的特性，以类的特性创建出来的副本。

你走进一栋建筑时，它的蓝图不太可能挂在墙上。类似的，你通常不会使用一个实例对象来直接访问并操作它的类，不过你至少可以判断它来自哪个类。

> 实例被创建出来后一般不会再用来访问类。

把类和实例对象之间的关系看作是直接关系，而不是间接关系通常更有助于理解。**类通过复制操作被实例化对象形式。**

> 实例与类之间的关系，是通过复制类里面的性质来成形。

### 构造函数

<u>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。</u>这个方法的任务就是初始化实例需要的所有信息。

举例来说，思考下面这个关于类的伪代码：

```js
class CoolGuy{
  specialTrick = nothing
  GoolGuy( trick ) {
    specialTrick = trick
  }
  showOff() {
    output( 'Here is my trick: ', specialTtick)
  }
}
```

我们可以调用类构造函数来生成一个 CoolGuy 实例：

```js
Joe = new CoolGuy( 'jumping rope' )
Joe.showOff() // 这就是我的绝技，跳绳
```

注意：CoolGuy 类有一个 CoolGuy() 构造函数，执行 new CoolGuy() 时实际上调用的就是它——构造函数。构造函数会返回一个对象（也就是类的实例），之后我们可以在这个对象上调用 showOff 方法，来输出指定 CoolGuy 的特长。

类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调用，这样语言引擎才知道你想要构造一个新的类实例。

> 这里的构造函数是介绍的面向对象的构造函数。

### 多态

Car 重写了继承自父类的 drive() 方法，但是之后 Car 调用了 inherited.drive() 方法，这表明了 Car 可以引用继承来原始 drive() 方法。快艇的 pilot() 方法同样引用了原始的 drive() 方法。

这个技术被称为多态或虚拟多态。在本例中，更恰当的说法是相对多态。

多态是一个非常广泛的话题，我们现在所说的「相对」只是多态的一个方面：<u>任何方法都可以引用继承层次中高层的方法。</u>之所以说「相对」是因为我们并不会想要访问的绝对继承层次，而是使用相对引用「查找上一层」。

在许多语言中可以使用 super 来替代本例中的 inherited：它的含义是「超类」superclass，表示当前类的父类或者祖先类。

<u>多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。</u>

在之前的代码中就有两个这样的例子：drive() 被定义在 Vehicle 和 Car 中，ignition() 被定义在 Vehicle 和 SpeedBoat 中。

> 作者在这里介绍的是传统语言中的多态。这里讲了太多的例子，看起来有些混乱。

我们可以在 ignition 中看到多态非常有趣的一点。在 pilot 中通过相对多态引用了 Vehicle 中的 drive。但是那个 drive 方法直接通过名字引用了 ignition 方法。

那么语言引擎会使用哪个 ignition 呢？ Vehicle 还是 SpeedBoat 的？实际上它会使用 SpeedBoat 的 ignition。如果你直接实例化了 Vehicle 类然后调用它的 drive，那语言引擎就会使用 Vehicle 中的 ignition 方法。

**换言之，ignition 方法中的定义的多态性取决于你是在哪个类的实例中引用它。**

<u>这似乎是一个过于深入的学术细节，但是只有深入了解这个细节才能理解 JavaScript 中的类似的 [[Prototype]] 机制。</u>

在子类中也可以相对引用它继承的父类，这种相对引用通常被称为 super。

![image-20220411174545046](https://s2.loli.net/2022/04/11/fORtKZVBsowY9jr.png)

注意这些实例（a1,a2,b1,b2）和继承（Bar）,箭头表示复制操作。

从概念上来说，子类 Bar 应当可以通过相对多态引用（或者说 super）来访问父类 Foo 中的行为。<u>需要注意的是，子类得到的仅仅是继承自父类行为的一个副本。</u>子类对继承到的一个方法进行重写，不会影响到父类的方法，这两个方法之间互不影响，因此才能使用相对多态访问父类中的方法。

<u>**多态并不表示子类和父类有关联，子类得到的只是父类的一个副本，类的继承其实就是复制。**</u>

> 作者在这里对多态进行了案例的介绍，观点只有一个：类的继承其实就是复制，子类是一个副本。

### 多重继承

还记得我们之前关于父类、子类的 DNA 讨论吗？当时我们说这个比喻不太恰当，因为现实中绝大多数是由双亲生的。如果类可以继承两个类，那看起来就更符合现实了。

有些面向对象的类允许你继承多个「父类」。多重继承意味着所有的父类的定义都会被复制到子类中。

从表面来看，对于类来说这似乎是一个非常有用的功能，可以把多个功能组合到一起，然而，这个机制同时也会带来复杂的问题。如果两个父类都定义了 drive 方法的话，那么子类引用的是哪一个呢？难道每次都需要手动指定具体父类的 drive 方法吗？

除此之外，还有一种被称为钻石问题的变种。在钻石问题中，子类 D 继承两个父类 B 和 C，这两个父类都继承自 A。如果 A 中有 drive 方法，并且 B 和 C 都重写了这个方法的，那么 D 引用 drive 时应该选择哪个版本呢？

这些问题远比看上去复杂得多，之所以要介绍这些问题，主要是为了和 JavaScript 的机制进行对比。

**相比之下，JavaScript 要简单的多：它本身并不提供「多重继承」功能。**许多人认为这是件好事，因为使用多重继承的代价太高。然而这无法阻挡开发者们的热情，他们会尝试各种办法来实现多重继承。



## 混入

在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。**简单来说，JavaScript 中只有对象，并不存在可以被实例化的「类」**。<u>一个对象并不会被复制到其他对象，它们会关联起来。</u>

由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者想出一个方法来模拟类的复制行为，这个方法就是**混入**。<u>接下来我们会看到两种类型的混入：显式和隐式。</u>

