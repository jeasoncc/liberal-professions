# JavaScript 优美的特性与糟粕

## JavaScript 优美的特性

精简的 JavaScript 里都是好东西，包括以下内容

- **函数是头等对象**。在精简 JavaScript 中，函数是有词法作用域的闭包。
- **基于原型继承的动态对象**。对象是无类别的，我们可以通过普通的赋值给任何对象增加一个新的成员元素，一个对象可以从另一个对象继承成员元素。
- **对象字面量和数组字面量**。这对创建新的对象和数字来说是一种非常方便的表示法。JavaScript 字面量是数据交换格式 JSON 的灵感之源。

## JavaScript 的糟粕

### 全局变量

**JavaScript 所有糟糕特性之中最为糟糕的就是它对全局变量的依赖性**。全局变量就是在所有作用域之中都可见的变量。全局变量在很小的程序中可能会带来方便，但随着程序变得越来越大，它们很快就变得难以处理。因为**一个全局变量可以被程序的任何部分在任意时间改变，它会使得程序的行为被极大的复杂化。在程序中使用全局变量降低了程序的可靠性。** 

全局变量使得在同一个程序中运行独立的子程序变得困难，如果某些全局变量的名称碰巧和子程序的变量名称相同，那么它们将会相互冲突并导致程序无法运行，而且通常还难以调试。

许多编程语言都有全局变量，例如，  Java 中的 public static 成员元素就是全局变量。JavaScript 的问题不仅在于它允许全局变量，而且在于它要求使用它们。JavaScript 没有链接器。所有的编译单元都载入一个公用的全局对象中。

共有三中方法定义全局变量。

第一种是脱离任何函数安排一个 var 语句：

```js
var foo = value
```

第二种是直接添加一个属性到全局对象上。全局对象是所有全局变量的容器，在 web 容器里，全局对象名为 window：

```js
window.foo = value
```

第三种是直接使用未经声明的变量，这被称为隐式的全局变量。

```js
foo = value
```

这本来是为方便初学者，而有意让变量在使用前无须声明。不幸的是，忘记声明变量成了一个非常普遍的错误。 JavaScript 的策略是让那些忘记预先声明的变量成为全局变量，这导致查找 bug 非常困难。

### 作用域

JavaScript 的语法来源于 C，在所有其他类似 C 语言风格的语言里，一个代码块会创造一个作用域。代码块声明的变量在其外部是不可见的。JavaScript 采用了这样的语法块，但没有提供块级作用域：**代码块中声明的变量在包含此代码块的函数的任何位置都是可见的。**

这让有其他编程经验的程序员们大为意外。在大多数语言中**，一般来说，声明变量最好的地方是在第一次用到它的地方。但这种做法在 JavaScript 里反而成了一个坏习惯，因为它没有块级作用域。更好的方式是在每个函数的开头部分声明所有变量。**

### 自动插入分号

JavaScript 有一个机制，它试图通过自动插入分号来修正有缺损的程序。千万不要依靠它，它可能会掩盖更为严重的错误。

有时它会不合时宜地插入分号，考虑下在 return 语句中自动插入分号导致的后果，如果一个 return 语句返回一个值，这个表达式的开始部分必须和 return 在同一行上：

```js
return 
{
    status: true
}
```

这看起来是要返回一个包含 status 成员元素的对象，不幸的是，自动插入分号让它变成了返回 undefined。自动插入分号导致程序被误解，却没有收到任何警告提示。如果把 { 放在上一行的尾部，而不是下一行的头部就可以避免该问题。

```js
return {
    status: true
}
```

### typeof

typeof 运算符返回一个用于识别其运算数类型的字符串，所以：

```js
typeof 100.0 
```

返回的是  'number' ，不幸的是：

```js
typeof null
```

返回的是 'object' 而不是 'null'。真糟糕，更好的检测 null 的方式其实很简单：

```js
my_value === null
```

一个更大的问题是检测对象的值。typeof 不能辨别 null 与对象，但你可以像下面这样做，因为 null 值为假，而所有对象值为真

```js
if (my_value && tyepof my_value === 'object'){
    ……
}
```

### parsenlnt

parseInt 是一个将字符串转换为整数的函数，它在遇到非数字时停止解析，所以 parasInt('16') 和 parasInt('16 foobar') 产生相同的结果。如果该函数会提醒我们出现了额外的文本就好了，但它不会那么做。

###  + 运算符

+运算符可以用于加法运算或字符串连接，它究竟会如何运行取决于其参数的类型。

- 如果其中一个运算数是一个空字符串，它会把另一个运算符转换成字符串并返回
- 如果两个运算符都是数字，它返回两者之和。
- 否则，它把两个运算数都转换为字符串并连接起来。

这个复杂行为是 bug 的常见来源，如果你打算用 + 去做加法运算，却确保两个运用数都是整数。

### 浮点数

**二进制的浮点数不能正确的处理十进制的小数，因此 0.1 + 0.2  不等于 0.3。**这是 JavaScript 中最经常被报告的 bug，并且它遵循二进制浮点数算数标准而有意导致的结果。

这个标准对很多应用都是合适的，但它违背了大多数你在中学时所学过的关于数字的知识。幸运的是，浮点数中的整数运算是精准的，所有小数表现出来的错误可以通过指定精度来避免。

### NaN

**NaN 是 IEEE（二进制浮点数算数标准） 754 中定义的一个特殊数量值，它表示不是一个数字，尽管下面的表达式返回的是 true**

```js
typeof NaN === 'number' // true
```

**该值可能会在试图将非数字形式的字符串转换成数字时产生。**

```js
+ '0' // 0
+ 'oops' //NaN
```

**如果 NaN 是数学运算中的一个运算符，那么结果就会是 NaN。所以，如果你有一个公式链产生出 NaN 的结果，那么至少其中一个输入项是 NaN。**

你可以对 NaN 进行检测，正如我们所见，typeof 不能辨别数字和 NaN，并且事实证明 **NaN 不等同于它自己**，所以，下面的代码结果令人惊讶：

```js
NaN === NaN // false
NaN !== NaN // true
```

JavaScript 提供了一个 isNaN 函数可以辨别数字与 NaN：

``` js
isNaN(NaN) // true
isNaN(0) //false
isNaN('oops') //true
isNaN('0') // false
```

判断一个值是否可用做数字的最佳方法是使用 isFinite 函数，因为它会筛选掉 NaN 和 Infinity。不幸的是， isFinite 会试图将它的运算数转换成一个数字，所以，如果值事实不是一个数字，它就不是一个好的测试。我们需要定义自己的 isNumber 函数。

```js
function isNumber(value) {
    return typeof value === 'number' && isFinite(value)
}
```

### 伪数组

JavaScript 没有真正的数组，这也不全是坏事。JavaScript 的数组确实很容易使用，不必给它们设置维度，而且它们永远不会产生越界错误。但它们的性能比真正的数组可能相当糟糕。

typeof 运算符不能辨别数组和对象，要判断一个值是否为数组，你还需要检查它的 constructor 属性：

```js
if(my_value && typeof my_value === 'object' && my_value.constructor === Array) {
    // my_value 是一个数组
}
```

arguments 伪数组不是一个数组，它是一个带有 length 成员元素的对象。上面的检测会将 arguments 数组识别为一个数组，有时候这是你希望得到的结果，尽管 arguments 不包含数组的任何方法。

### 假值

JavaScript 拥有令人惊讶的一大组假值

| 值         | 类型      |
| ---------- | --------- |
| 0          | Number    |
| NaN        | Number    |
| ''空字符串 | String    |
| false      | Boolean   |
| null       | Object    |
| undefined  | Undefined |

这些值全部都等同于假，但它们是不可互换的

```js
var my_vlaue = myObject[name]
if(my_value == null) {
    console.log(name + 'not found')
}
```

undefined 是缺失的成员元素的值，但该代码片段用 null 来测试，它使用了会强制类型转换的 == 运算符，而不是更可靠的 === 运算符。

**undefined 和 NaN  并不是常量，它们是全局变量，而且你可以改变它们的值，那本是不应该的，但事实确实如此，千万不要这样做。**

### hasOwnProperty

hasOwnProperty 是一个方法，而不是一个运算符，所以在任何对象中，它可能被一个不同函数甚至一个非函数的值所替换。

 ```js
 var name
 another_stooge.hasOwnProperty = null // 地雷
 for(name in another_stooge) {
     if(another_stooge.hasOwnProperty(name)) { // 触雷
         // 操作
     }
 }
 ```



### 对象

JavaScript 对象永远不会有真的空对象，因为它们可以从原型链中取得成员元素。有时候那会带来些麻烦。