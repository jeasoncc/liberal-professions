# JavaScript 鸡肋

这一章展示一些 JavaScript 一些有问题的特性，但我们很容易就能避免它们。通过这些简单的做法，你就可以使 JavaScript 成为一门更好的语言，也能让自己成为一个更好的程序员。

## ==

JavaScript 有两个相等运算符： === 和 !==，以及它们邪恶的孪生兄弟 == 和 !=。

===  和 !== 这一组运算符会按照你期望的方式工作。如果两个运算数类型一致并且拥有相同的值，那么 === 才会返回 true，!== 返回 false。

而它们邪恶的孪生兄弟只有在两个运算符类型一致时才会做出正确的判断，但**如果两个运算数是不同类型时，它们试图去强制类型转换其值的类型**。

转换的规则复杂，且难以记忆。

```js
''  == '0' // false
0 == '' // true
0 == '0' // ture

false == 'false' // false
false == '0' // true 

false == undefined // false
false == null // false
null == undefined // true

'\t\r\n' == 0 // true
```

== 运算符对传递性的缺乏值得我们警惕。

我的建议是永远不要使用那对邪恶的孪生兄弟，相反，请始终使用 === 和 !==。所有以上的比较如果使用 === 运算符，结果都是 false。

## with语句

JavaScript 提供了一个 with 语句，本意是想用来快捷的访问对象的属性，不幸的是，它的结果可能有时不可预料，所以应该避免使用它。

下面的语句：

```js
with (obj) {
    a = b
}
```

和下面的代码做的是一样的事情：

```js
if(obj.a === undefined){
    a = obj.b === undefined ? b : obj.b
} else {
    obj.a = obj.b = undefined ? b : obj.b
}
```

所以，它等于这些语句中的任何一条：

```js
a = b
a = obj.b
obj.a = b
obj.a = obj.b
```

通过阅读代码，你不可能辨别出你会得到是这些语句中的哪一条。它可能随着程序运行到下一步时发生变化。它甚至可能在程序运行过程中就发生变化了。如果你不能通过阅读程序而了解它将会做什么，你就无法确信它会正确地做你想要做的事情。

**with 语句在该门语言中存在，本身就严重影响了 JavaScript 处理器的速度，因为它阻止了变量名的词法作用域绑定**。它的本意是好的，但如果没有它，JavaScript 语言会更好一点。

## eval

eval 函数传递字符串给 JavaScript 编译器，并且执行其结果。它是一个被滥用最多的 JavaScript 特性，那些对 JavaScript 语言一知半解的人们最长用到它。例如，你知道点表示法，但不知道下标表示法，就可能会这么写：

```js
eval('my_value = myObject.' + myKey + ';')
```

而不是这么写：

```js
my_value = myObject[myKey]
```

**使用 eval 形式的代码会更加难以阅读，这种形式将使得性能显著降低，因为它必须运行编译器，但也许只是为了执行一个微不足道的赋值语句。**它也会让 JSLint 失效。因此该工具检测问题的能力也会显著降低。

**eval 函数还减弱了你的应用的安全性，因为它被求值的文本授予了太多的权力。**而且就像 with 语句执行的方式一样，它降低了语言的性能。

<u>Function 构造器是 eval 的另一种形式，所以它同样也应该被避免使用。</u>

<u>浏览器提供的 setTimeout 和 setInerval 函数，它们能接受字符串参数或函数参数。</u>

**当传递的是字符串参数时， setTimeout 和 setInterval 会像 eval 那样去处理**。字符串参数形式也应该被避免使用。	

## continue 语句

continue 语句跳到循环的顶部，我发现一段代码通过重构移除 continue 语句之后，性能都会得到改善。

## 缺少块语句

if、while、do 或 for 语句可以接受一个花括号中的代码块，也可以接受单行语句。单行语句的形式是另一种带刺的玫瑰。它带来的好处是可以节约两个字节，但这是不是个好处值得商榷。它模糊了程序的结构，使得在随后的操作代码中可能很容易插入错误。

```js
if(ok)
t = true
```

可能变成：

```js
if(ok)
    t = true
	advance()
```

它看起来像是要这样：

```js
if(ok){
    t = true
    advance()
}
```

但实际上它的本意却是：

```js
if(ok) {
    t = true
}
advance()
```

貌似在做一件事，但实际上却是在做另一件事的程序是非常难理清楚的。严格规范并始终使用代码块会使得代码更容易理解。

## ++ 和 --

递增和递减运算符使得程序员可以用非常简洁的风格去编码。

然而，这两个运算符容易促成一种不谨慎的编程风格。大多数的缓冲区溢出错误所造成的安全漏洞，都是由于像这样的编码所导致的。

在我自己的实践中，我观察到，当我使用 ++ 和 -- 时，代码往往变得过为紧密、复杂和隐晦。因此，作为一条原则，我不再使用它们。那会让代码风格变得更为整洁。

## 位运算符

| 符号 | 意思         |
| ---- | ------------ |
| &    | 按位与       |
| \|   | 按位或       |
| ^    | 按位异或     |
| >>   | 带符号的右移 |
| >>>  | 无符号的右移 |
| <<   | 无符号的左移 |

在 Java 里，位运算符处理的是整数， JavaScript 没有整数类型，它只是双精度的浮点数。

因此，**位操作符将它们的数字运算先转换成整数，接着执行运用，然后再转换回去**。<u>在大多数运算中，这些位运算符接近于硬件处理而非常快，在 JavaScript 中，它们非但不是硬件处理，而且非常慢。JavaScript 很少被用来执行位操作。</u>

另一个结果是，在 JavaScript 程序中， & 非常容易被误写为 && 运算符。位运算符出现在 JavaScript 中降低了这门语言的冗余度，使得 bug 更容易被隐藏起来。

## function 语句对比函数表达式

JavaScript 中既有 function 语句，同时也有函数表达式。这是令人困惑的，因为它们看起来好像就是一样的，**一个 function 语句就是其值为一个函数的 var 语句的速记形式。**

下面的语句：

```js
funtion foo() {
    
}
```

意思相当于

```js
var foo	= function foo() {}
```

我一直使用的是第二种形式，因为它能明确的表示 **foo 是一个包含一个函数值的变量。**

要想用好这门语言，理解函数据数值是很重要的。

**function 语句在解析时会发生<u>被提升的情况</u>，这意味着不管 function 被放到哪里，它会被移动到被定义时所在作用域的顶层。这放宽了函数必须先声明后使用的要求，而我认为这会导致混乱。**

在 if 语句中使用 function 语句也是被禁止的，虽然在大多数浏览器中都允许在 if 语句里使用 function 语句，但它们在解析时的处理各不相同，那就造成了兼容性的问题。

一个语句不能以一个函数表达式开头，因为官方的语法假定以单词 function 开头的语句是一个 function 语句。解决方法就是把函数表达式括在一个圆括号之中。

```js
(function () {
    // 具体操作
})()
```

## 类型的包装对象

JavaScript 中有一套类型的包装对象。

```js
new Boolean(false)
```

会返回一个对象，该对象有一个 valueOf 方法会返回被包装的值。<u>这其实完全没有必要，并且有时还令人困惑。</u>**不要使用 new Boolean、 new Number 或 new String。**

**此外也请避免使用 new Object 和 new Arrary。可使用 { }  和 [ ] 来代替。**

## new 

JavaScript 的 **new 运算符创建一个继承于其运算数（构造器函数）的原型的新对象，然后调用该运算数，把新创建的对象绑定给 this**。这给运算数（它应该是一个构造器函数）一个机会在返回给请求者前去自定义新创建的对象。

如果你忘记了使用此运算符，你所得到的就是一个普通的函数调用，并且 this 绑定到全局对象，而不是新创建的对象。那意味着你的函数尝试去初始化时，它将会污染全局变量，那是一件非常糟糕的事情，而且没有编译警告，也没有运行时警告。

按照惯例，打算与 new 结合使用的函数应该命名为首字母大写的形式，并且首字母大写的形式应该只用来命名那些构造器函数。这个约定给我们提供了一个视觉线索，以帮助我们发现那些 JavaScript 语言自身经常忽略，但却会带来昂贵代价的错误。

一个更好的应对策略就根本不去使用 new。

## void

在很多语言中， void 是一种类型，表示没有什么值。而在 JavaScript 里，void 是一个运算符，它接受一个运算数并返回  undefined，这没有什么用，而且会令人非常困惑，应该完全避免使用它。

